;;
;;	FEL_Browser
;;	Tool for snooping through FEL diffraction images
;;
;;	Anton Barty, 2010-2012
;;

;;
;;	FInd hits
;;
pro fel_browser_findhits, pstate

	;;
	;;	error trapping
	;;
		if (*pstate).global.nfiles eq 0 then $
			return
		if NOT ptr_valid((*pstate).global.background_data) then begin
			result = dialog_message('No background image defined')
			return
		endif

	;;
	;;	Which files are currently selected?
	;;
		selection = widget_info((*pstate).table.files, /table_select)
		if (selection[0] eq -1) then begin 
			result = dialog_message('No images selected')
			return
		endif
		sel_start = selection[1]
		sel_end = selection[3]

	;;
	;;	Dialog box for parameters
	;;
		form_desc=[ '1, BASE,, column, frame', $
					'0, LABEL, Analysis options, left, ', $
					'0, DROPLIST, Correlation|Intensity change|R-factor, set_value=0, tag=method', $
					'0, BUTTON, Running background update|Use annular ROI|Use exponential filter, set_value=0, tag=options', $
					'0, FLOAT, 0.05, label_left = Inner ROI radius (% size), tag = inner_roi_radius', $
					'0, FLOAT, 0.5, label_left = Outer ROI radius, tag = outer_roi_radius', $
					'2, LABEL, (ROI radius = fraction of largest image dimension), left, ', $
					
					'1, BASE,, column, frame', $
					'0, LABEL, Thresholds, left, ', $
					'0, FLOAT, 0.05, label_left=Definite hit threshold, tag=hit_threshold', $
					'0, FLOAT, 0.02, label_left=Maybe hit threshold , tag=maybe_threshold', $
					'2, TEXT,,label_left=Output filename, width=50, tag=outfile', $
					'1, BASE,,row', $
					'0, BUTTON, OK, QUIT, tag=ok', $
					'2, BUTTON, Cancel, QUIT' $
				  ]

		form = cw_form(form_desc,/column)
		if form.ok ne 1 then $
			return
				
	;;
	;;	Extract key parameters from form field
	;;
		hit_threshold = form.hit_threshold
		maybe_threshold = form.maybe_threshold
		inner_ROI = form.inner_roi_radius
		outer_ROI = form.outer_roi_radius
		option_runningBackground = form.options[0]
		option_useROI = form.options[1]
		option_useFilter = form.options[2]
		outfile = form.outfile
		n_files = 0
		n_hits = 0
		n_maybe = 0
		
		background = float((*(*pstate).global.background_data))
		s_bg = size(background,/dim)
		n_bg = 1
		n_bg_sum = 1
		
	;;
	;;	Set up the log file
	;;
		if outfile ne '' then begin
			openw, fp, outfile, /get_lun
			printf, fp, '#  Hit list generated by fel_browser'
			printf, fp, '#  ', systime(0)
			printf, fp, '#  ', (*pstate).global.directory
			close, fp
			free_lun, fp
		endif

	;;
	;;	Loop through selected files
	;;
		WIDGET_CONTROL, /HOURGLASS
		for i=sel_start, sel_end do begin
		
			;;
			;; Load next image
			;;
				(*pstate).global.currentFileID = i
				WIDGET_CONTROL, (*pstate).table.files, SET_TABLE_SELECT=[-1,i,-1,i]
				fel_browser_loadimage,pstate

				raw_image = float(*((*pstate).global.image_data))
				directory =	(*pstate).global.directory
				filenum = (*pstate).global.currentFileID
				filename = (*(*pstate).global.filenames)[filenum]

			;;
			;; Update text
			;;
				text1 = strcompress(string(n_hits,' out of ',n_files,' ' ))
				text2 = strcompress(string('(',100.*float(n_hits)/n_files,'%)'), /remove_all)
				WIDGET_CONTROL, (*pstate).text.listText2, SET_VALUE = text1 + text2 + ' hit'


			;;
			;;	Current background image
			;;
				image = raw_image
				this_bg = (background/float(n_bg_sum))
				
			;;
			;;	If image sizes do not match just skip (rather than crash)
			;;
				if n_elements(image) ne n_elements(this_bg) then $
					continue
			
			
			;;
			;;	Ignore points that are missing data (= the minimum value) 
			;;	(eg: ignore gaps between CCD) 
			;;
				min_img = min(image)
				min_bg = min(this_bg)
				w = where(this_bg eq min_bg OR image eq min_img)
				if w[0] ne -1 then begin
					this_bg[w] = 0
					image[w] = 0
				endif
				this_bg -= min_bg
				image -= min_img
				
			;;
			;;	Ignore points where the background is bright 
			;;
				w = where(this_bg gt 0.1*max(this_bg))
				if w[0] ne -1 then begin
					this_bg[w] = 0
					image[w] = 0
				endif
				
			;;
			;; ROI mask?
			;;
				if (option_useROI eq 1) then begin
					s = size(image,/dim)
					cx = s[0]*(*pstate).global.img_centre[0]
					cy = s[1]*(*pstate).global.img_centre[1]
					xx = xarr(s[0],s[1]) - cx
					yy = yarr(s[0],s[1]) - cy
					d = sqrt(xx*xx+yy*yy)
					
					r1 = inner_ROI*max(s)/2
					r2 = outer_ROI*max(s)/2
					w = where(d ge r1 AND d le r2)
					
					if w[0] ne -1 then begin
						this_bg = this_bg[w]
						image = image[w]
					endif
				endif
				
				
			;;
			;;	Ignore regions tagged to be ignored. 
			;;	If speed is an issue the 'look at these regions' mask could be 
			;;	passed from a higher level as an array rather than calculated on each iteration
			;;
				w = where(this_bg ne 0 AND image ne 0)
				if w[0] ne -1 then begin
					this_bg = this_bg[w]
					image = image[w]
				endif
				


			;;
			;; Weight images so that low intensity regions recieve more weight in the calculation
			;;	using an exponential filter
			;; (ie: don't get overwhelmed by variations in only the intense central spot)
			;;
				if option_useFilter eq 1 then begin
					this_bg = (this_bg>0)^0.2
					image = (image>0)^0.2
				endif


			;;
			;;	Hit finding algorithm itself
			;;
				case form.method of
					;; Compute normalised Pearson correlation between background and current image
					0 : begin
						this_bg -= mean(this_bg)
						image -= mean(image)
		
						p1 = abs(total(image*this_bg))
						n1 = sqrt(total(this_bg^2))
						n2 = sqrt(total(image^2))
						R = 1-p1/(n1*n2)
						end
	
					;; Look at ratios of total intensity in current image vs background image 
					1 : begin
						t1 = total(this_bg)
						t2 = total(image)
						R = t2/t1 - 1
						end
				
					;;	Use R factor, with both images normalised for total intensity in each frame 
					2 : begin
						k =  total(image)/total(this_bg)
						diff = image - k*this_bg
						R = total(abs(diff)) / total(this_bg)
						end

				endcase
			
			;;
			;; Classify
			;;
				n_files+=1
				if R gt hit_threshold then begin
					hit = 1
					n_hits += 1
					message = 'Hit'
				endif $
				else if R gt maybe_threshold then begin
					hit = 1
					n_maybe += 1
					message = 'Maybe'
				endif $
				else begin
					hit = 0
					message = 'Blank'
					n_bg += 1
					if option_runningBackground eq 1 then begin
						;background += raw_image
						;n_bg_sum += 1
						background = (9*background + raw_image)/10
						n_bg_sum = 1
					endif
				endelse

			;;
			;; Print 'Hit/Miss' message on image
			;;
				(*(*pstate).global.metadata)[i,(*pstate).global.metadata_columns.hits] = message
				(*(*pstate).global.metadata)[i,(*pstate).global.metadata_columns.hitStrength] = string(R)

				oldwin = !d.window
				wset, (*pstate).window.preview
				loadct, (*pstate).global.colour_table, /silent
				xyouts, 10, 10, message+strcompress(string(' R = ',R)), /dev			
				if oldwin ne -1 then $
					wset, oldwin

			;;
			;;	Save running file list somewhere...
			;;
				if outfile ne '' then begin
					str1 = filename
					str2 = message
					str3 = string(R)
					outstr = str1+', '+str2+', '+str3
					
					openw, fp, outfile, /append, /get_lun
					printf, fp, outstr
					close, fp
					free_lun, fp
				endif

			;;	Abort ?
				;if get_kbrd(0) eq 'q' then $
				;	return
		endfor

		;;
		;; Final report		
		;;
			text1 = strcompress(string(n_hits,' out of ',n_files,' files are hits ' ))
			text2 = strcompress(string('(',100.*float(n_hits)/n_files,'%)'), /remove_all)
			WIDGET_CONTROL, (*pstate).text.listText2, SET_VALUE = text1 + text2
			WIDGET_CONTROL, (*pstate).table.files, SET_TABLE_SELECT=[-1,sel_start,-1,sel_end]

			widget_control, (*pstate).menu.comment_Hits, set_button=1
			widget_control, (*pstate).menu.comment_HitStrength, set_button=1
			fel_browser_displaycomments, pstate


end
